---
title: Standardizing Non-standard Evaluation in R
author: itcarroll
category: blog
tags:
 - R
 - data.table
---

Partway through her LTER Postdoc at SESYNC, ecologist Meghan Avolio ran into trouble manipulating her data on plant communities with `dplyr` functions. I had encouraged Meghan to modularize her scripts by writing functions for common steps in her pipeline (such as converting count data into rank-abundance curves). "You'll love writing functions!" I said wrongly.

Meghan quickly ran up against the trickery of non-standard evaluation (NSE) as employed by most of the `dplyr` functions. In calls to `mutate`, `filter`, `group_by` and friends, column names are supplied without quotation marks. NSE makes an expression like `mutate(df, rank = rank(abund))` fail when `abund` is a string variable. Accepting column names as strings is a pretty good idea when writing functions to process data frames with unknown columns, but not with `dplyr`.

NSE can be glimpsed elsewhere in R -- it's what lets you leave package names unquoted in the command `library(dplyr)`. Without NSE, that command would fail with the message <span style="color:red;">`Error: object 'dplyr' not found`</span>. After all, nothing called `dplyr` exists in the global environment. If the unquoted `dplyr` in `library(dplyr)` doesn't exist in the global environment, how can this expression achieve the same result as the standard evaluation call `library("dplyr")`? The absense of quotation marks is the proverbial tip of an iceberg, so buckle up your crampons and read on.

As a contrived example of when the savvy `dplyr` user needs to know about NSE, suppose you want to write a function that does for arbitrary data frames what the following does for `plots` (the script at the end of this post will create `plots`):

```{r, include = FALSE}
plots <- read.csv(textConnection("
  Plot, SpeciesNumber, Genus,  Species, Cover
  1,    2,             androp, gerar,   4
  1,    3,             schiza, scopa,   1
  1,    15,            panicu, virga,   6
  2,    2,             androp, gerar,   3
  2,    15,            panicu, virga,   4
  2,    18,            sorgha, nutan,   1
  2,    21,            sporob, compo,   1
"), strip.white=TRUE)
```

```{r}
library(dplyr)
plots %>%
    filter(Plot == 2) %>%
    summarize(mean=mean(Cover))
```

An **incorrect** attempt at such a function is:

```{r}
level_mean_nope <- function(data, factor, level, value) {
  data %>%
    filter(factor == level) %>%
    summarize(mean=mean(value))
}
```

The intent above is to filter in rows that have the value of `level` in whichever column is named `factor`, and subsequently apply the function `mean` to whichever column is named `value`. But try it and be warned:

```{r}
level_mean_nope(plots, 'Plot', 2, 'Cover')
```

What's worse than the warning is that the answer given, `NA`, is wrong! Without the `summarize` part, there would be no error or warning, but the result would not be what you want either.

By the way, have you read the [NSE vignette] for the `dplyr` package? Did it help? Yeah, me neither.

Let's go back to `library(dplyr)` and talk about R's lazy evaluation mechanism, or more specifically, about [promise objects]. Very briefly, when you use a function, its arguments are *not* evaluated before handing off to the function's internals. The call to `library` does not try to evaluate `dplyr` before starting through the code within the `library` function -- the interpreter is "lazy". If I were a lazy interpreter, I'd accept any note you handed me and promise to read it when the time comes. Moreover, I'd promise to read it in the context it was given, so references in the note to 'this' or 'those' would be to things present when you gave me the instruction. By using the stored context, R functions appear to evaluate the function's arguments in a standard way ... they just won't unless absolutely necessary (hence "lazy").

Technically, when the R interpreter encounters a function call, each argument gets embedded in an object representing itself as an expression (i.e. a bit of code) along with a pointer to the environment in which the function was called. This promise object can evaluate the expression in that environment when needed, so it conveys the correct value like any normal variable would. But you can perform sneaky tricks with a promise object, too. The `library(dplyr)` command records the expression `dplyr` and infers the string `"dplyr"`, without ever attempting to evaluate the expression (which would fail in the global environment!). All this to save you the trouble of typing quotation marks.

Like the `library` function, `filter` and `summarize` look at the embedded expression rather than instruct the lazy interpreter to get on with evaluating it. You *can* do the same, but *should* you?

First, the "yes you can". The purpose of `substitute` is to modify code itself. # FIXME

Come again, now? The purpose of `substitute(expr)` is to modify `expr` using variables in the current environment. Inside a function, the environment includes the promise objects created from each argument, and `substitute(expr)` will replace any code in `expr` mentioning a promise object with the expression it promised to evaluate.

[code language="r" firstline="20"]
level_mean <- function(data, factor, level, value) {
  only_this_level <- substitute(factor == level)
  mean_of_value <- substitute(mean(value))
  data %>%
    filter_(only_this_level) %>%
    summarize_(mean=mean_of_value)
}
[/code]

Focus on line 21, where substitute gets the expression `factor == level`. The first part of the expression will be substituted for the *expression* embedded in the promise object `factor`, whatever it may be when `level_mean` gets used. The same happens for `level`, and the result is stored as `only_this_level`. At line 24, notice the underscore in `filter_` and another in `summarize_` on the next line. Since we are implementing our own NSE, we have to bypass the `dplyr` mechanism for lazy evaluation, and that's exactly what the underscored functions do. All the `dplyr` "verbs" have variants that accept the result of a `substitute` -- they also accept character strings, but that's for another post.

Now try using your function with `dplyr` style unquoted arguments:

[code gutter="false"]
> level_mean(plots, Plot, 2, Cover)
  mean
1 2.25
[/code]

See how it works? The call to `filter_` ended up something like `filter_(Plots == 2)` and then `summarize_` got `mean=mean(Cover)`. Challenge question! In the following call, why should `'panicu'` remain in quotes?
[code gutter="false"]
> level_mean(plots, Genus, 'panicu', Cover)
  mean
1    5
[/code]

**Expand the source below to access and copy a continuous version of the preceding code chunks.**

[code language="r" collapse="true"]
library(dplyr)

plots <- read.csv(textConnection("
  Plot, SpeciesNumber, Genus,  Species, Cover
  1,    2,             androp, gerar,   4
  1,    3,             schiza, scopa,   1
  1,    15,            panicu, virga,   6
  2,    2,             androp, gerar,   3
  2,    15,            panicu, virga,   4
  2,    18,            sorgha, nutan,   1
  2,    21,            sporob, compo,   1
"), strip.white=TRUE)

level_mean_fail <- function(data, factor, level, value) {
  data %>%
    filter(factor == level) %>%
    summarize(mean=mean(value))
}

level_mean <- function(data, factor, level, value) {
  only_this_level <- substitute(factor == level)
  mean_of_value <- substitute(mean(value))
  data %>%
    filter_(only_this_level) %>%
    summarize_(mean=mean_of_value)
}
[/code]

[NSE vignette]: https://cran.r-project.org/web/packages/dplyr/vignettes/nse.html
[promise objects]: https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Promise-objects
